UseEffect Learnings -Concept

1ï¸âƒ£ The core idea (before syntax)

You already know this:

Rendering = React showing UI based on state

Now hereâ€™s the key question ğŸ‘‡
When should code run that is NOT directly about rendering UI?

Examples:

Fetching data from an API

Listening to window resize

Saving to localStorage

Starting a timer

ğŸ‘‰ These are called side effects
---------------------------------------------
etching data is the classic side effect.

2ï¸âƒ£ Why useEffect exists (the problem it solves)

Letâ€™s think without useEffect first.

Imagine this component:

function User() {
  const [user, setUser] = useState(null);

  fetch("/api/user")
    .then(res => res.json())
    .then(data => setUser(data));

  return <div>{user?.name}</div>;
}


âš ï¸ Problem:
Every time state updates â†’ component re-renders â†’ fetch runs again â†’ infinite loop

So React needed a way to say:

â€œRun this code after render, and only when I tell you to.â€

ğŸ‘‰ Thatâ€™s useEffect

3ï¸âƒ£ Mental model (VERY important)
ğŸ§  Think of useEffect as:

â€œAfter React finishes rendering, run this effect.â€

Not during render.
Not before render.
After.

Simple analogy ğŸŒ±

Render = setting up the room

useEffect = turning on the AC, calling someone, opening a window

You donâ€™t rearrange furniture inside the AC logic.

4ï¸âƒ£ Basic syntax (no magic yet)
useEffect(() => {
  // side effect code
}, []);


Two parts:

Effect function â†’ what to run

Dependency array â†’ when to run

Before I explain the arrayâ€¦

Question ğŸ‘‡

What do you think the empty array [] might mean?
------------------------------------------------------------
5ï¸âƒ£ Dependency array (the control panel)

Your idea is correct. Hereâ€™s the precise mental model:

The dependency array tells React when to re-run the effect AFTER render

Three common patterns ğŸ”
1ï¸âƒ£ Run once (on mount)
useEffect(() => {
  console.log("Runs once");
}, []);


âœ”ï¸ Empty array
âœ”ï¸ Runs after first render only

ğŸ§  Think: â€œComponent just appeared on screenâ€

2ï¸âƒ£ Run when something changes
useEffect(() => {
  console.log("User changed");
}, [userId]);


âœ”ï¸ Runs on first render
âœ”ï¸ Runs again only if userId changes

ğŸ§  Think: â€œReact, watch this variableâ€

3ï¸âƒ£ Run after every render (rare)
useEffect(() => {
  console.log("Every render");
});


âš ï¸ Usually avoid â€” easy to cause loops

6ï¸âƒ£ Real-world example: Fetching data (correct way)

Letâ€™s connect this to what you said earlier ğŸ‘‡

function User({ userId }) {
  const [user, setUser] = useState(null);

  useEffect(() => {
    fetch(`/api/users/${userId}`)
      .then(res => res.json())
      .then(data => setUser(data));
  }, [userId]);

  return <div>{user?.name}</div>;
}

Why this works:

UI renders

useEffect runs after render

Fetch happens

State updates â†’ re-render

Effect runs again only if userId changes

7ï¸âƒ£ Cleanup (real world necessity)

Some effects leave â€œmessâ€ behind ğŸ˜¬
Examples:

Event listeners

Timers

WebSocket connections

Example: window resize listener
useEffect(() => {
  function handleResize() {
    console.log(window.innerWidth);
  }

  window.addEventListener("resize", handleResize);

  return () => {
    window.removeEventListener("resize", handleResize);
  };
}, []);


ğŸ§  Analogy:

Effect = turning something on

Cleanup = turning it off

React runs cleanup before the effect runs again
and when the component unmounts

8ï¸âƒ£ Common use cases (youâ€™ll see these everywhere)

âœ”ï¸ Fetching data
âœ”ï¸ Subscribing/unsubscribing (events, sockets)
âœ”ï¸ Syncing state with:

localStorage

URL params

document title

Example:

useEffect(() => {
  document.title = `Count: ${count}`;
}, [count]);

9ï¸âƒ£ Common mistakes (important âš ï¸)

âŒ Missing dependencies
âŒ Updating state thatâ€™s also a dependency â†’ infinite loop
âŒ Doing heavy logic inside render instead of useEffect

ğŸ” Quick check (teach it back)

Answer one question:

In your own words:
When does useEffect run, and what does the dependency array control?

After that, Iâ€™ll:

Show a localStorage example

Explain why ESLint complains

Give you a one-line memory trick ğŸ§ 
--------------------------------------------------------------------------]
useEffect runs after the component renders.
It runs on the first render, and again only when values in the dependency array change.